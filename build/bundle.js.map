{"version":3,"file":"bundle.js","sources":["../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../../node_modules/@babel/runtime/helpers/esm/typeof.js","../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../../node_modules/@babel/runtime/helpers/esm/inherits.js","../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../../node_modules/@babel/runtime/helpers/esm/createClass.js","../../node_modules/svelte/internal/index.mjs","../../node_modules/@turf/helpers/index.js","../../node_modules/@turf/meta/index.js","../../node_modules/@turf/bbox/index.js","../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../../node_modules/svelte/store/index.mjs","../../src/stores.js","../../src/components/AutoCompleteSearch.svelte","../../src/components/Map.svelte","../../src/components/Charts.svelte","../../src/App.svelte","../../src/main.js"],"sourcesContent":["export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","import _typeof from \"../../helpers/esm/typeof\";\nimport assertThisInitialized from \"./assertThisInitialized\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","import setPrototypeOf from \"./setPrototypeOf\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","import arrayWithoutHoles from \"./arrayWithoutHoles\";\nimport iterableToArray from \"./iterableToArray\";\nimport nonIterableSpread from \"./nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}","export default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}","export default function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value = ret) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value' || descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group) {\n    const value = [];\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.push(group[i].__value);\n    }\n    return value;\n}\nfunction to_number(value) {\n    return value === '' ? undefined : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction claim_element(nodes, name, attributes, svg) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeName === name) {\n            let j = 0;\n            while (j < node.attributes.length) {\n                const attribute = node.attributes[j];\n                if (attributes[attribute.name]) {\n                    j++;\n                }\n                else {\n                    node.removeAttribute(attribute.name);\n                }\n            }\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return svg ? svg_element(name) : element(name);\n}\nfunction claim_text(nodes, data) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 3) {\n            node.data = '' + data;\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return text(data);\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.data !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    if (value != null || input.value) {\n        input.value = value;\n    }\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    node.style.setProperty(key, value, important ? 'important' : '');\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\nfunction add_resize_listener(element, fn) {\n    if (getComputedStyle(element).position === 'static') {\n        element.style.position = 'relative';\n    }\n    const object = document.createElement('object');\n    object.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;');\n    object.setAttribute('aria-hidden', 'true');\n    object.type = 'text/html';\n    object.tabIndex = -1;\n    let win;\n    object.onload = () => {\n        win = object.contentDocument.defaultView;\n        win.addEventListener('resize', fn);\n    };\n    if (/Trident/.test(navigator.userAgent)) {\n        element.appendChild(object);\n        object.data = 'about:blank';\n    }\n    else {\n        object.data = 'about:blank';\n        element.appendChild(object);\n    }\n    return {\n        cancel: () => {\n            win && win.removeEventListener && win.removeEventListener('resize', fn);\n            element.removeChild(object);\n        }\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, false, false, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor(html, anchor = null) {\n        this.e = element('div');\n        this.a = anchor;\n        this.u(html);\n    }\n    m(target, anchor = null) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(target, this.n[i], anchor);\n        }\n        this.t = target;\n    }\n    u(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    p(html) {\n        this.d();\n        this.u(html);\n        this.m(this.t, this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\n\nconst active_docs = new Set();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = node.ownerDocument;\n    active_docs.add(doc);\n    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);\n    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});\n    if (!current_rules[name]) {\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ``}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        active_docs.forEach(doc => {\n            const stylesheet = doc.__svelte_stylesheet;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            doc.__svelte_rules = {};\n        });\n        active_docs.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error(`Function called outside component initialization`);\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        callbacks.slice().forEach(fn => fn(event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\nlet flushing = false;\nconst seen_callbacks = new Set();\nfunction flush() {\n    if (flushing)\n        return;\n    flushing = true;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        for (let i = 0; i < dirty_components.length; i += 1) {\n            const component = dirty_components[i];\n            set_current_component(component);\n            update(component.$$);\n        }\n        dirty_components.length = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    flushing = false;\n    seen_callbacks.clear();\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = program.b - t;\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            info.blocks[i] = null;\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\n\nconst globals = (typeof window !== 'undefined' ? window : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next, lookup.has(block.key));\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error(`Cannot have duplicate keys in a keyed each`);\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, classes_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (classes_to_add) {\n        if (attributes.class == null) {\n            attributes.class = classes_to_add;\n        }\n        else {\n            attributes.class += ' ' + classes_to_add;\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += \" \" + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += \" \" + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${String(value).replace(/\"/g, '&#34;').replace(/'/g, '&#39;')}\"`;\n        }\n    });\n    return str;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(parent_component ? parent_component.$$.context : []),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, options = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, options);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `\"${value}\"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : ``;\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    // onMount happens before the initial afterUpdate\n    add_render_callback(() => {\n        const new_on_destroy = on_mount.map(run).filter(is_function);\n        if (on_destroy) {\n            on_destroy.push(...new_on_destroy);\n        }\n        else {\n            // Edge case - component was destroyed immediately,\n            // most likely as a result of a binding initialising\n            run_all(new_on_destroy);\n        }\n        component.$$.on_mount = [];\n    });\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const prop_values = options.props || {};\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(parent_component ? parent_component.$$.context : []),\n        // everything else\n        callbacks: blank_object(),\n        dirty\n    };\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, prop_values, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if ($$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor);\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set() {\n            // overridden by instance, if it has props\n        }\n    };\n}\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set() {\n        // overridden by instance, if it has props\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.20.0' }, detail)));\n}\nfunction append_dev(target, node) {\n    dispatch_dev(\"SvelteDOMInsert\", { target, node });\n    append(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev(\"SvelteDOMInsert\", { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev(\"SvelteDOMRemove\", { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? [\"capture\"] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev(\"SvelteDOMAddEventListener\", { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev(\"SvelteDOMRemoveEventListener\", { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev(\"SvelteDOMRemoveAttribute\", { node, attribute });\n    else\n        dispatch_dev(\"SvelteDOMSetAttribute\", { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev(\"SvelteDOMSetProperty\", { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev(\"SvelteDOMSetDataset\", { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.data === data)\n        return;\n    dispatch_dev(\"SvelteDOMSetData\", { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(`'target' is a required option`);\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn(`Component was already destroyed`); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error(`Infinite loop detected`);\n        }\n    };\n}\n\nexport { HtmlTag, SvelteComponent, SvelteComponentDev, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_transform, afterUpdate, append, append_dev, assign, attr, attr_dev, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_space, claim_text, clear_loops, component_subscribe, compute_rest_props, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, escape, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getContext, get_binding_group_value, get_current_component, get_slot_changes, get_slot_context, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, has_prop, identity, init, insert, insert_dev, intros, invalid_attribute_name_character, is_client, is_function, is_promise, listen, listen_dev, loop, loop_guard, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, update_keyed_each, validate_component, validate_each_argument, validate_each_keys, validate_slots, validate_store, xlink_attr };\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.370,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.370,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, options) {\n    if (options === void 0) { options = {}; }\n    switch (type) {\n        case \"Point\": return point(coordinates).geometry;\n        case \"LineString\": return lineString(coordinates).geometry;\n        case \"Polygon\": return polygon(coordinates).geometry;\n        case \"MultiPoint\": return multiPoint(coordinates).geometry;\n        case \"MultiLineString\": return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\": return multiPolygon(coordinates).geometry;\n        default: throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num) && !/^\\s*$/.test(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error(\"method has been renamed to `radiansToDegrees`\");\n}\nexports.radians2degrees = radians2degrees;\nfunction degrees2radians() {\n    throw new Error(\"method has been renamed to `degreesToRadians`\");\n}\nexports.degrees2radians = degrees2radians;\nfunction distanceToDegrees() {\n    throw new Error(\"method has been renamed to `lengthToDegrees`\");\n}\nexports.distanceToDegrees = distanceToDegrees;\nfunction distanceToRadians() {\n    throw new Error(\"method has been renamed to `lengthToRadians`\");\n}\nexports.distanceToRadians = distanceToRadians;\nfunction radiansToDistance() {\n    throw new Error(\"method has been renamed to `radiansToLength`\");\n}\nexports.radiansToDistance = radiansToDistance;\nfunction bearingToAngle() {\n    throw new Error(\"method has been renamed to `bearingToAzimuth`\");\n}\nexports.bearingToAngle = bearingToAngle;\nfunction convertDistance() {\n    throw new Error(\"method has been renamed to `convertLength`\");\n}\nexports.convertDistance = convertDistance;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        var previousFeatureIndex = 0;\n        var previousMultiIndex = 0;\n        var prevGeomIndex = 0;\n        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n                previousCoords = currentCoord;\n                previousFeatureIndex = featureIndex;\n                previousMultiIndex = multiPartIndexCoord;\n                prevGeomIndex = geometryIndex;\n                segmentIndex = 0;\n                return;\n            }\n            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        if (feature.geometry === null) return;\n        var type = feature.geometry.type;\n        var coords = feature.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return helpers.point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return helpers.point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return helpers.point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.coordAll = coordAll;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.findSegment = findSegment;\nexports.findPoint = findPoint;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar meta_1 = require(\"@turf/meta\");\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {GeoJSON} geojson any GeoJSON object\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction bbox(geojson) {\n    var result = [Infinity, Infinity, -Infinity, -Infinity];\n    meta_1.coordEach(geojson, function (coord) {\n        if (result[0] > coord[0]) {\n            result[0] = coord[0];\n        }\n        if (result[1] > coord[1]) {\n            result[1] = coord[1];\n        }\n        if (result[2] < coord[0]) {\n            result[2] = coord[0];\n        }\n        if (result[3] < coord[1]) {\n            result[3] = coord[1];\n        }\n    });\n    return result;\n}\nexports.default = bbox;\n","import arrayWithHoles from \"./arrayWithHoles\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit\";\nimport nonIterableRest from \"./nonIterableRest\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}","import { noop, safe_not_equal, subscribe, run_all, is_function } from '../internal';\nexport { get_store_value as get } from '../internal';\n\nconst subscriber_queue = [];\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier}start start and stop notifications for subscriptions\n */\nfunction readable(value, start) {\n    return {\n        subscribe: writable(value, start).subscribe,\n    };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=}start start and stop notifications for subscriptions\n */\nfunction writable(value, start = noop) {\n    let stop;\n    const subscribers = [];\n    function set(new_value) {\n        if (safe_not_equal(value, new_value)) {\n            value = new_value;\n            if (stop) { // store is ready\n                const run_queue = !subscriber_queue.length;\n                for (let i = 0; i < subscribers.length; i += 1) {\n                    const s = subscribers[i];\n                    s[1]();\n                    subscriber_queue.push(s, value);\n                }\n                if (run_queue) {\n                    for (let i = 0; i < subscriber_queue.length; i += 2) {\n                        subscriber_queue[i][0](subscriber_queue[i + 1]);\n                    }\n                    subscriber_queue.length = 0;\n                }\n            }\n        }\n    }\n    function update(fn) {\n        set(fn(value));\n    }\n    function subscribe(run, invalidate = noop) {\n        const subscriber = [run, invalidate];\n        subscribers.push(subscriber);\n        if (subscribers.length === 1) {\n            stop = start(set) || noop;\n        }\n        run(value);\n        return () => {\n            const index = subscribers.indexOf(subscriber);\n            if (index !== -1) {\n                subscribers.splice(index, 1);\n            }\n            if (subscribers.length === 0) {\n                stop();\n                stop = null;\n            }\n        };\n    }\n    return { set, update, subscribe };\n}\nfunction derived(stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single\n        ? [stores]\n        : stores;\n    const auto = fn.length < 2;\n    return readable(initial_value, (set) => {\n        let inited = false;\n        const values = [];\n        let pending = 0;\n        let cleanup = noop;\n        const sync = () => {\n            if (pending) {\n                return;\n            }\n            cleanup();\n            const result = fn(single ? values[0] : values, set);\n            if (auto) {\n                set(result);\n            }\n            else {\n                cleanup = is_function(result) ? result : noop;\n            }\n        };\n        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {\n            values[i] = value;\n            pending &= ~(1 << i);\n            if (inited) {\n                sync();\n            }\n        }, () => {\n            pending |= (1 << i);\n        }));\n        inited = true;\n        sync();\n        return function stop() {\n            run_all(unsubscribers);\n            cleanup();\n        };\n    });\n}\n\nexport { derived, readable, writable };\n","import { writable } from \"svelte/store\";\n\nexport const dataStore = writable(null)\nexport const mapStore = writable(null)","<script>\n    import {dataStore, mapStore} from '../stores'\n    let value = ''\n    let searchItems = []\n    let values = []\n    $: {\n        if($dataStore){\n            values = $dataStore.facility.features.map(feature => {\n                const prop = feature.properties;\n                const { name , system } = prop;\n                const coords = feature.geometry.coordinates;\n                return {name ,system, coords, text: `${name.toLowerCase()}, ${system.toLowerCase()}`}\n            })\n        }\n    }\n\n\n    function _set(item){\n        //reset\n        searchItems = []\n        value = item.name;\n\n        //zoom to location\n        $mapStore.flyTo({center: item.coords, zoom: 13})\n    }\n\n    function _search() {\n        if (value.length > 1) {\n            searchItems = values.filter(v => v.text.includes(value.toLowerCase())).slice(0,5)\n        }\n    }\n</script>\n\n<div class=\"content\">\n    <input class=\"search\"\n           type=\"text\"\n           placeholder=\"Type here to search by Hospital or System\"\n           bind:value\n           autocomplete=\"off\"\n           on:keyup=\"{_search}\"/>\n    <div class=\"autocomplete-items\">\n        {#each searchItems as item}\n            <div on:click=\"{() => _set(item)}\"><strong>{item.name}</strong>{item.system ? ` | ${item.system}`: ''}</div>\n        {/each}\n    </div>\n</div>\n\n<style>\n    .content{\n        position: relative;\n    }\n    .search {\n        width: 100%;\n    }\n\n    .autocomplete-items {\n        position: absolute;\n        border: 1px solid #d4d4d4;\n        border-bottom: none;\n        border-top: none;\n        z-index: 99;\n        /*position the autocomplete items to be the same width as the container:*/\n        top: 100%;\n        left: 0;\n        right: 0;\n    }\n\n    .autocomplete-items div {\n        padding: 5px 10px;\n        cursor: pointer;\n        background-color: #fff;\n        border-bottom: 1px solid #e0e0e0;\n    }\n\n    .autocomplete-items div:hover {\n        /*when hovering an item:*/\n        background-color: #e9e9e9;\n    }\n\n</style>","<script>\n    import {\n        onMount\n    } from 'svelte';\n    import {dataStore, mapStore} from '../stores'\n    let container;\n    let map;\n\n    onMount(() => {\n        map = new mapboxgl.Map({\n            container: 'map',\n            style: carto.basemaps.voyager,\n            center: [-76.358493, 42.650281],\n            zoom: 5.3\n        });\n\n        //set map to store\n        mapStore.set(map)\n    })\n\n    $: {\n        //init sources and layers\n        if(map && $dataStore){\n            const countySource = new carto.source.GeoJSON($dataStore.county);\n            const facilitySource = new carto.source.GeoJSON($dataStore.facility);\n\n            const countyLayer = new carto.Layer('county', countySource, new carto.Viz(`\n                color: ramp(\n                    zoomRange([6,10]),\n                        [opacity(ramp(buckets($lawsuits_per_10000, [0,1,11,51,101,150]),\n                        [#d8d9da, #e2f7fe,#bfe1ec,#91c4db,#69b1ce,#006a92,#003b54]),1)\n                        opacity(ramp(buckets($lawsuits_per_10000, [0,1,11,51,101,150]),\n                        [#d8d9da, #e2f7fe,#bfe1ec,#91c4db,#69b1ce,#006a92,#003b54]),0.2)\n                    ]\n                    )\n                strokeWidth: 1\n                strokeColor: ramp(zoomRange([6,8]),[#f9f9f9,#959595])\n            `));\n\n            const facilityLayer = new carto.Layer('facility', facilitySource, new carto.Viz(`\n                @category: ramp($system,prism)\n                @name: $name\n                @system: $system\n                @lawsuits: $lawsuits\n                @link: $link\n                width: ramp(zoomrange([5,6.5,10]),[1.5,4,scaled($lawsuits,16) + 2])\n                strokeColor: ramp(zoomRange([5,7]),[#f9f9f9,#959595])\n                color: ramp(zoomRange([5,7]),[white,opacity(@category,0.8)])\n            `));\n\n            countyLayer.addTo(map);\n            facilityLayer.addTo(map);\n\n            //popup\n            const interactivity = new carto.Interactivity(facilityLayer);\n            interactivity.on('featureClick', featureEvent => {\n                const coords = featureEvent.coordinates;\n                const features = featureEvent.features;\n\n                if(features.length > 0){\n                    let html = []\n                    features.forEach(feature => {\n                        const { name, system , lawsuits, link} = feature.variables\n                        html.push(`\n                            <h4><a target=\"_blank\" href=\"${feature.link}\">${name.value}</a></h4>\n                            ${system ? `<p><strong>System:</strong> ${system.value}</p>` : ''}\n                            <p><strong>Amount of Lawsuits:</strong> ${lawsuits.value}</p>\n                         `)\n                    })\n\n                    new mapboxgl.Popup()\n                            .setLngLat([coords.lng, coords.lat])\n                            .setHTML(html.join('<br/>'))\n                            .addTo(map);\n                }\n            });\n        }\n    }\n\n</script>\n\n<div class=\"content\">\n<div id=\"map\" bind:this={container}></div>\n</div>\n\n<style>\n    .content{\n        height: 500px;\n        flex: 1 1 340px;\n        min-width: 340px;\n        overflow: auto;\n        background: #ebebeb;\n        display: flex;\n        flex-direction: column;\n    }\n    #map {\n        width: 100%;\n        height: 100%;\n    }\n    :global(.mapboxgl-popup-content) {\n        overflow: auto;\n        max-height: 200px;\n    }\n\n    :global(.mapboxgl-popup-content p, h4) {\n        margin: 0px 5px;\n    }\n</style>","<script>\n    import {dataStore, mapStore} from '../stores'\n\n    let container;\n\n    $: {\n        if ($dataStore) {\n            const margin = {top: 20, right: 20, bottom: 100, left: 40},\n                    width = 400 - margin.left - margin.right,\n                    height = 400 - margin.top - margin.bottom;\n\n            // set the ranges\n            const x = d3.scaleBand()\n                    .range([0, width])\n                    .padding(0.1);\n            const y = d3.scaleLinear()\n                    .range([height, 0]);\n\n            function getColor(num) {\n                return num > 150\n                        ? \"#003b54\"\n                        : num > 101\n                                ? \"#006a92\"\n                                : num > 51\n                                        ? \"#69b1ce\"\n                                        : num > 11\n                                                ? \"#91c4db\"\n                                                : num > 1\n                                                        ? \"#bfe1ec\"\n                                                        : num > 0\n                                                                ? \"#e2f7fe\"\n                                                                : \"#d8d9da\";\n            }\n\n            // append the svg object to the body of the page\n            // append a 'group' element to 'svg'\n            // moves the 'group' element to the top left margin\n            const svg = d3.select(container)\n                    .attr(\"width\", width + margin.left + margin.right)\n                    .attr(\"height\", height + margin.top + margin.bottom)\n                    .append(\"g\")\n                    .attr(\"transform\",\n                            \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n\n            // Define the div for the tooltip\n            const tooltip = d3.select(\"body\").append(\"div\")\n                    .attr(\"class\", \"tooltip\")\n                    .style(\"opacity\", 0);\n\n            const facility_data = $dataStore.county.features.map(feature => feature.properties).filter(feature => feature.lawsuits_per_10000)\n            x.domain(facility_data.map(function (d) {\n                return d.name;\n            }));\n            y.domain([0, d3.max(facility_data, function (d) {\n                return d.lawsuits_per_10000;\n            })]);\n\n            // append the rectangles for the bar chart\n            svg.selectAll(\".bar\")\n                    .data(facility_data)\n                    .enter().append(\"rect\")\n                    .attr(\"class\", \"bar\")\n                    .attr(\"x\", function (d) {\n                        return x(d.name);\n                    })\n                    .attr(\"width\", x.bandwidth())\n                    .attr(\"y\", function (d) {\n                        return y(d.lawsuits_per_10000);\n                    })\n                    .attr(\"height\", function (d) {\n                        return height - y(d.lawsuits_per_10000);\n                    })\n                    .attr(\"fill\", function (d) {\n                        return getColor(d.lawsuits_per_10000)\n                    })\n                    .on(\"mouseover\", d => {\n                        tooltip.transition()\n                                .duration(100)\n                                .style(\"opacity\", .9);\n                        tooltip.html(`\n                                <p><strong>${d.name}</strong></p>\n                                <p><strong>Lawsuits:</strong> ${d.lawsuits}</p>\n                                <p><strong>Rate per 10,000:</strong> ${d.lawsuits_per_10000}</p>\n                        `)\n                                .style(\"left\", (d3.event.pageX) + \"px\")\n                                .style(\"top\", (d3.event.pageY - 28) + \"px\");\n                    })\n                    .on(\"mouseout\", d => {\n                        tooltip.transition()\n                                .duration(400)\n                                .style(\"opacity\", 0);\n                    })\n                    .on(\"click\", d => {\n                        $mapStore.fitBounds(d.bounds, {\n                            padding: 20\n                        });\n                    })\n\n            // add the x Axis\n            svg.append(\"g\")\n                    .attr(\"transform\", \"translate(0,\" + height + \")\")\n                    .call(d3.axisBottom(x))\n                    .selectAll(\"text\")\n                    .style(\"text-anchor\", \"end\")\n                    .attr(\"dx\", \"-.8em\")\n                    .attr(\"dy\", \".15em\")\n                    .attr(\"transform\", \"rotate(-60)\")\n\n            // add the y Axis\n            svg.append(\"g\")\n                    .call(d3.axisLeft(y));\n        }\n    }\n</script>\n\n<div class=\"content\">\n    <h4>Hospital Lawsuits Against Patients by County, 2015–2019</h4>\n    <h5>Rate per  10,000 People</h5>\n    <svg bind:this={container}></svg>\n    <h6>Zoom in or search to show lawsuits by hospital facility</h6>\n</div>\n\n<style>\n    .content {\n        height: 500px;\n        flex: 1 1 420px;\n        min-width: 420px;\n        overflow: auto;\n        background: #f6f6f6;\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n    }\n\n    h4{\n        margin-top: 1rem;\n    }\n\n    h5{\n        margin: 0;\n        color: #999999;\n    }\n\n    svg {\n        font: 10px sans-serif;\n    }\n\n\n    :global(div.tooltip) {\n        color: white;\n        position: absolute;\n        text-align: center;\n        width: 100px;\n        padding: 2px;\n        font: 12px sans-serif;\n        background: rgba(0, 0, 0, .8);\n        pointer-events: none;\n    }\n\n    :global(div.tooltip p) {\n        margin: 2px;\n    }\n\n    .button {\n        background-color: #ddd;\n        border: none;\n        color: black;\n        padding: 10px 20px;\n        text-align: center;\n        text-decoration: none;\n        display: inline-block;\n        margin: 4px 2px;\n        cursor: pointer;\n        border-radius: 16px;\n    }\n\n</style>","<script>\n    import {\n        onMount\n    } from 'svelte';\n    import bbox from '@turf/bbox'\n    import AutoCompleteSearch from './components/AutoCompleteSearch.svelte'\n    import Map from './components/Map.svelte'\n    import Charts from './components/Charts.svelte'\n    import {dataStore} from './stores'\n\n    onMount(() => {\n        //init data via d3js, then process data into to geojson\n        Promise.all([\n            d3.json(\"./datasets/new-york-counties.geojson\"),\n            d3.csv(\"./datasets/county-lawsuits-filed-between-2015–2019.csv\"),\n            d3.csv(\"./datasets/facility-lawsuits-filed-between-2015–2019.csv\")\n        ]).then(function (files) {\n            //extract geojson from topojson\n            const county = files[0] //topojson.feature(files[0], files[0].objects.cb_2015_new_york_county_20m);\n\n            //combine county data with csv\n            county.features.forEach(feature => {\n                //look up in csv\n                const name = feature.properties['NAME'];\n                const lawsuits = files[1].find(item => item['County'] === name)\n\n                if (lawsuits) {\n                    //calculate bounds\n\n                    const bounds = bbox(feature)\n\n                    feature.properties = {\n                        name,\n                        lawsuits: +lawsuits[\"Number of Lawsuits\"],\n                        lawsuits_per_10000: +lawsuits[\"Rate per 10,000 People\"],\n                        bounds\n                    }\n                } else {\n                    feature.properties = {name, lawsuits: null, lawsuits_per_10000: null}\n                }\n\n            })\n\n            //generate geojson from csv point data\n            const facility = {\n                \"type\": \"FeatureCollection\",\n                \"features\": []\n            }\n\n            files[2].forEach(item => {\n                facility.features.push({\n                    \"type\": \"Feature\",\n                    \"properties\": {\n                        name: item['Standardized Facility Name'].trim(),\n                        system: item['System'].trim(),\n                        lawsuits: +item['Number of Lawsuits'],\n                        link: item['Link'].trim(),\n                        id: item['ID']\n                    },\n                    \"geometry\": {\n                        \"type\": \"Point\",\n                        \"coordinates\": [\n                            item['Lng'],\n                            item['Lat']\n                        ]\n                    }\n                })\n            })\n\n            dataStore.set({\n                county,\n                facility\n            })\n        }).catch(function (err) {\n            // handle error here\n            console.error(err.message)\n        })\n    })\n</script>\n\n<main>\n   <AutoCompleteSearch/>\n    <div class=\"vis\">\n        <Map/>\n        <Charts/>\n    </div>\n</main>\n\n<style>\n    .vis {\n        display: flex;\n        flex-wrap: wrap;\n        box-shadow: 2px 2px rgba(30, 30, 30, 0.8);\n        border: 1px solid;\n        position: relative;\n    }\n</style>","import App from './App.svelte';\n\nconst app = new App({\n\ttarget: document.body\n});\n\nexport default app;"],"names":["_classCallCheck","instance","Constructor","TypeError","_typeof","obj","Symbol","iterator","constructor","prototype","_assertThisInitialized","self","ReferenceError","_possibleConstructorReturn","call","assertThisInitialized","_getPrototypeOf","o","Object","setPrototypeOf","getPrototypeOf","__proto__","_setPrototypeOf","p","_inherits","subClass","superClass","create","value","writable","configurable","_toConsumableArray","arr","Array","isArray","i","arr2","length","arrayWithoutHoles","iter","toString","from","iterableToArray","nonIterableSpread","_defineProperties","target","props","descriptor","enumerable","defineProperty","key","noop","run","fn","blank_object","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","component_subscribe","component","store","callback","$$","on_destroy","push","callbacks","unsub","subscribe","unsubscribe","append","node","appendChild","insert","anchor","insertBefore","detach","parentNode","removeChild","element","name","document","createElement","text","data","createTextNode","space","listen","event","handler","options","addEventListener","removeEventListener","attr","attribute","removeAttribute","getAttribute","setAttribute","children","childNodes","set_data","set_input_value","input","current_component","set_current_component","onMount","Error","get_current_component","on_mount","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","add_render_callback","flushing","seen_callbacks","Set","flush","update","pop","has","add","clear","fragment","before_update","dirty","ctx","after_update","outroing","transition_in","block","local","delete","transition_out","outros","c","d","create_component","mount_component","m","new_on_destroy","map","filter","destroy_component","detaching","make_dirty","then","fill","init","create_fragment","not_equal","parent_component","prop_values","bound","context","Map","ready","ret","hydrate","nodes","l","intro","SvelteComponent","protoProps","staticProps","this","$destroy","type","index","indexOf","splice","feature","geom","properties","feat","id","bbox","geometry","point","coordinates","polygon","_i","coordinates_1","ring","j","lineString","featureCollection","features","fc","multiLineString","multiPoint","multiPolygon","radiansToLength","radians","units","factor","exports","factors","lengthToRadians","distance","radiansToDegrees","Math","PI","isNumber","num","isNaN","test","centimeters","earthRadius","centimetres","degrees","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","yards","acres","coords","geometries","precision","multiplier","pow","round","bearing","angle","originalUnit","finalUnit","area","startFactor","areaFactors","finalFactor","coordEach","geojson","excludeWrapCoord","k","stopG","geometryMaybeCollection","isGeometryCollection","wrapShrink","coordIndex","isFeatureCollection","isFeature","stop","featureIndex","geomIndex","multiFeatureIndex","geometryIndex","geomType","propEach","featureEach","geomEach","g","featureProperties","featureBBox","featureId","undefined","flattenEach","helpers","segmentEach","segmentIndex","previousCoords","previousFeatureIndex","previousMultiIndex","prevGeomIndex","currentCoord","featureIndexCoord","multiPartIndexCoord","currentSegment","lineEach","initialValue","previousValue","currentProperties","currentFeature","coord","currentGeometry","started","currentLine","isObject","result","Infinity","meta_1","_slicedToArray","arrayWithHoles","_arr","_n","_d","_e","_s","next","done","err","iterableToArrayLimit","nonIterableRest","subscriber_queue","start","subscribers","set","new_value","run_queue","s","invalidate","subscriber","dataStore","mapStore","system","iterations","searchItems","values","_set","item","$mapStore","flyTo","center","zoom","$dataStore","facility","prop","toLowerCase","v","includes","slice","container","mapboxgl","style","carto","basemaps","voyager","countySource","source","GeoJSON","county","facilitySource","countyLayer","Layer","Viz","facilityLayer","addTo","Interactivity","on","featureEvent","html","variables","lawsuits","link","Popup","setLngLat","lng","lat","setHTML","join","createElementNS","margin","top","right","bottom","left","width","height","x","d3","scaleBand","range","padding","y","scaleLinear","svg","select","tooltip","facility_data","lawsuits_per_10000","domain","max","selectAll","enter","bandwidth","transition","duration","pageX","pageY","fitBounds","bounds","axisBottom","axisLeft","all","json","csv","files","find","trim","catch","console","error","message","body"],"mappings":"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"}